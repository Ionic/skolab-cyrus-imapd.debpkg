Description: walk bytewise up to alignment boundary before fast slices 
Author: Ellie Timoney <https://github.com/elliefm>
Origin: upstream, https://github.com/cyrusimap/cyrus-imapd/compare/cyrus-imapd-3.2...elliefm:v32/3040-crc-alignment
Bug: https://github.com/cyrusimap/cyrus-imapd/issues/3040
Bug-Debian: https://bugs.debian.org/960658
Forwarded: not-needed
Reviewed-By: Xavier Guimard <yadd@debian.org>
Last-Update: 2020-05-20

--- a/configure.ac
+++ b/configure.ac
@@ -181,6 +181,12 @@
   AC_MSG_ERROR(The Cyrus IMAPD requires support for long long int)
 fi
 
+dnl Check the required alignment for various types
+AC_CHECK_ALIGNOF(uint32_t)
+
+dnl check for -R, etc. switch
+CMU_GUESS_RUNPATH_SWITCH
+
 AC_CHECK_HEADERS(unistd.h sys/select.h sys/param.h stdarg.h)
 AC_REPLACE_FUNCS(memmove strcasecmp ftruncate strerror posix_fadvise strsep memmem)
 AC_CHECK_FUNCS(strlcat strlcpy strnchr getgrouplist fmemopen pselect)
--- a/cunit/crc32.testc
+++ b/cunit/crc32.testc
@@ -1,4 +1,5 @@
 /* Unit test for lib/crc32.c */
+#include <config.h>
 #include "cunit/cyrunit.h"
 #include "crc32.h"
 #include "crc32c.h"
@@ -105,6 +106,31 @@
     CU_ASSERT_EQUAL(c, CRC32);
 }
 
+static void test_unaligned(void)
+{
+    struct aligned_data {
+        char pad1[1];
+        char UNALIGNED_TEXT[12];
+        char pad2[3];
+        char ALIGNED_TEXT[12];
+    } __attribute__((packed, aligned (ALIGNOF_UINT32_T)));
+
+    static const struct aligned_data data = {
+        { 0 },
+        "lorem ipsum",
+        { 0 },
+        "lorem ipsum",
+    };
+    static const uint32_t CRC32 = 0x72d7748e;
+    uint32_t c;
+
+    c = crc32_map(data.UNALIGNED_TEXT, sizeof(data.UNALIGNED_TEXT)-1);
+    CU_ASSERT_EQUAL(c, CRC32);
+
+    c = crc32_map(data.ALIGNED_TEXT, sizeof(data.ALIGNED_TEXT)-1);
+    CU_ASSERT_EQUAL(c, CRC32);
+}
+
 static void test_iovec(void)
 {
     static const char TEXT1[] = "lorem";
--- a/lib/crc32.c
+++ b/lib/crc32.c
@@ -630,7 +630,16 @@
 static uint32_t crc32_slice8(uint32_t prev, const void *data, size_t length)
 {
     uint32_t crc = ~prev;
-    const uint32_t* current = (const uint32_t*) data;
+    unsigned unaligned = (uintptr_t) data % ALIGNOF_UINT32_T;
+    const uint8_t *current_char;
+    const uint32_t *current;
+
+    /* process a byte at a time until we hit an alignment boundary */
+    current_char = (const uint8_t *) data;
+    for (; unaligned && length; unaligned--, length--)
+        crc = (crc >> 8) ^ crc32_lookup[0][(crc & 0xFF) ^ *current_char++];
+
+    current = (const uint32_t *) current_char;
 
     /* process eight bytes at once (Slicing-by-8) */
     while (length >= 8) {
@@ -661,7 +670,7 @@
         length -= 8;
     }
 
-    const uint8_t* current_char = (const uint8_t*) current;
+    current_char = (const uint8_t*) current;
     /* remaining 1 to 7 bytes (standard algorithm) */
     while (length-- != 0)
         crc = (crc >> 8) ^ crc32_lookup[0][(crc & 0xFF) ^ *current_char++];
@@ -673,7 +682,16 @@
 static uint32_t crc32_slice16(uint32_t prev, const void *data, size_t length)
 {
     uint32_t crc = ~prev;
-    const uint32_t* current = (const uint32_t*) data;
+    unsigned unaligned = (uintptr_t) data % ALIGNOF_UINT32_T;
+    const uint8_t *current_char;
+    const uint32_t *current;
+
+    /* process a byte at a time until we hit an alignment boundary */
+    current_char = (const uint8_t *) data;
+    for (; unaligned && length; unaligned--, length--)
+        crc = (crc >> 8) ^ crc32_lookup[0][(crc & 0xFF) ^ *current_char++];
+
+    current = (const uint32_t *) current_char;
 
     /* enabling optimization (at least -O2) automatically unrolls the inner for-loop */
     const size_t unroll = 4;
@@ -683,54 +701,54 @@
         size_t unrolling;
         for (unrolling = 0; unrolling < unroll; unrolling++) {
 #if BYTE_ORDER == LITTLE_ENDIAN
-        uint32_t one   = *current++ ^ crc;
-        uint32_t two   = *current++;
-        uint32_t three = *current++;
-        uint32_t four  = *current++;
-        crc = crc32_lookup[ 0][(four  >> 24) & 0xFF] ^
-              crc32_lookup[ 1][(four  >> 16) & 0xFF] ^
-              crc32_lookup[ 2][(four  >>  8) & 0xFF] ^
-              crc32_lookup[ 3][ four         & 0xFF] ^
-              crc32_lookup[ 4][(three >> 24) & 0xFF] ^
-              crc32_lookup[ 5][(three >> 16) & 0xFF] ^
-              crc32_lookup[ 6][(three >>  8) & 0xFF] ^
-              crc32_lookup[ 7][ three        & 0xFF] ^
-              crc32_lookup[ 8][(two   >> 24) & 0xFF] ^
-              crc32_lookup[ 9][(two   >> 16) & 0xFF] ^
-              crc32_lookup[10][(two   >>  8) & 0xFF] ^
-              crc32_lookup[11][ two          & 0xFF] ^
-              crc32_lookup[12][(one   >> 24) & 0xFF] ^
-              crc32_lookup[13][(one   >> 16) & 0xFF] ^
-              crc32_lookup[14][(one   >>  8) & 0xFF] ^
-              crc32_lookup[15][ one          & 0xFF];
+            uint32_t one   = *current++ ^ crc;
+            uint32_t two   = *current++;
+            uint32_t three = *current++;
+            uint32_t four  = *current++;
+            crc = crc32_lookup[ 0][(four  >> 24) & 0xFF] ^
+                  crc32_lookup[ 1][(four  >> 16) & 0xFF] ^
+                  crc32_lookup[ 2][(four  >>  8) & 0xFF] ^
+                  crc32_lookup[ 3][ four         & 0xFF] ^
+                  crc32_lookup[ 4][(three >> 24) & 0xFF] ^
+                  crc32_lookup[ 5][(three >> 16) & 0xFF] ^
+                  crc32_lookup[ 6][(three >>  8) & 0xFF] ^
+                  crc32_lookup[ 7][ three        & 0xFF] ^
+                  crc32_lookup[ 8][(two   >> 24) & 0xFF] ^
+                  crc32_lookup[ 9][(two   >> 16) & 0xFF] ^
+                  crc32_lookup[10][(two   >>  8) & 0xFF] ^
+                  crc32_lookup[11][ two          & 0xFF] ^
+                  crc32_lookup[12][(one   >> 24) & 0xFF] ^
+                  crc32_lookup[13][(one   >> 16) & 0xFF] ^
+                  crc32_lookup[14][(one   >>  8) & 0xFF] ^
+                  crc32_lookup[15][ one          & 0xFF];
 #else
-        uint32_t one   = *current++ ^ swap(crc);
-        uint32_t two   = *current++;
-        uint32_t three = *current++;
-        uint32_t four  = *current++;
-        crc = crc32_lookup[ 0][ four         & 0xFF] ^
-              crc32_lookup[ 1][(four  >>  8) & 0xFF] ^
-              crc32_lookup[ 2][(four  >> 16) & 0xFF] ^
-              crc32_lookup[ 3][(four  >> 24) & 0xFF] ^
-              crc32_lookup[ 4][ three        & 0xFF] ^
-              crc32_lookup[ 5][(three >>  8) & 0xFF] ^
-              crc32_lookup[ 6][(three >> 16) & 0xFF] ^
-              crc32_lookup[ 7][(three >> 24) & 0xFF] ^
-              crc32_lookup[ 8][ two          & 0xFF] ^
-              crc32_lookup[ 9][(two   >>  8) & 0xFF] ^
-              crc32_lookup[10][(two   >> 16) & 0xFF] ^
-              crc32_lookup[11][(two   >> 24) & 0xFF] ^
-              crc32_lookup[12][ one          & 0xFF] ^
-              crc32_lookup[13][(one   >>  8) & 0xFF] ^
-              crc32_lookup[14][(one   >> 16) & 0xFF] ^
-              crc32_lookup[15][(one   >> 24) & 0xFF];
+            uint32_t one   = *current++ ^ swap(crc);
+            uint32_t two   = *current++;
+            uint32_t three = *current++;
+            uint32_t four  = *current++;
+            crc = crc32_lookup[ 0][ four         & 0xFF] ^
+                  crc32_lookup[ 1][(four  >>  8) & 0xFF] ^
+                  crc32_lookup[ 2][(four  >> 16) & 0xFF] ^
+                  crc32_lookup[ 3][(four  >> 24) & 0xFF] ^
+                  crc32_lookup[ 4][ three        & 0xFF] ^
+                  crc32_lookup[ 5][(three >>  8) & 0xFF] ^
+                  crc32_lookup[ 6][(three >> 16) & 0xFF] ^
+                  crc32_lookup[ 7][(three >> 24) & 0xFF] ^
+                  crc32_lookup[ 8][ two          & 0xFF] ^
+                  crc32_lookup[ 9][(two   >>  8) & 0xFF] ^
+                  crc32_lookup[10][(two   >> 16) & 0xFF] ^
+                  crc32_lookup[11][(two   >> 24) & 0xFF] ^
+                  crc32_lookup[12][ one          & 0xFF] ^
+                  crc32_lookup[13][(one   >>  8) & 0xFF] ^
+                  crc32_lookup[14][(one   >> 16) & 0xFF] ^
+                  crc32_lookup[15][(one   >> 24) & 0xFF];
 #endif
         }
 
         length -= bytes_at_once;
     }
 
-    const uint8_t* current_char = (const uint8_t*) current;
+    current_char = (const uint8_t*) current;
     /* remaining 1 to 63 bytes (standard algorithm) */
     while (length-- != 0)
         crc = (crc >> 8) ^ crc32_lookup[0][(crc & 0xFF) ^ *current_char++];
