From 523a91a5e86c8b9a27a138f04a3e3f2d8786f162 Mon Sep 17 00:00:00 2001
From: Ken Murchison <murch@andrew.cmu.edu>
Date: Fri, 25 Mar 2011 15:50:18 +0000
Subject: Fixed bug #3423 - STARTTLS plaintext command injection vulnerability

---
--- a/imap/imapd.c
+++ b/imap/imapd.c
@@ -1414,6 +1414,9 @@ void cmdloop()
 		if (c == '\r') c = prot_getc(imapd_in);
 		if (c != '\n') goto extraargs;
 
+		/* XXX  discard any input pipelined after STARTTLS */
+		prot_flush(imapd_in);
+
 		/* if we've already done SASL fail */
 		if (imapd_userid != NULL) {
 		    prot_printf(imapd_out, 
--- a/imap/lmtpengine.c
+++ b/imap/lmtpengine.c
@@ -1551,6 +1551,9 @@ void lmtpmode(struct lmtp_func *func,
 		sasl_ssf_t ssf;
 		char *auth_id;
 
+		/* XXX  discard any input pipelined after STARTTLS */
+		prot_flush(pin);
+
 		/* SASL and openssl have different ideas
 		   about whether ssf is signed */
 		layerp = &ssf;
--- a/imap/mupdate.c
+++ b/imap/mupdate.c
@@ -828,6 +828,9 @@ mupdate_docmd_result_t docmd(struct conn
 	if (!strcmp(c->cmd.s, "Starttls")) {
 	    CHECKNEWLINE(c, ch);
 	    
+	    /* XXX  discard any input pipelined after STARTTLS */
+	    prot_flush(c->pin);
+
 	    if (!tls_enabled()) {
 		/* we don't support starttls */
 		goto badcmd;
--- a/imap/nntpd.c
+++ b/imap/nntpd.c
@@ -1402,6 +1402,9 @@ static void cmdloop(void)
 		if (c == '\r') c = prot_getc(nntp_in);
 		if (c != '\n') goto extraargs;
 
+		/* XXX  discard any input pipelined after STARTTLS */
+		prot_flush(nntp_in);
+
 		cmd_starttls(0);
 	    }
 	    else if (!strcmp(cmd.s, "Stat")) {
--- a/imap/pop3d.c
+++ b/imap/pop3d.c
@@ -699,6 +699,9 @@ static void cmdloop(void)
 		prot_printf(popd_out,
 			    "-ERR STLS doesn't take any arguments\r\n");
 	    } else {
+		/* XXX  discard any input pipelined after STLS */
+		prot_flush(popd_in);
+
 		cmd_starttls(0);
 	    }
 	}
--- a/lib/prot.c
+++ b/lib/prot.c
@@ -533,10 +533,29 @@ int prot_fill(struct protstream *s)
 }
 
 /*
+ * If 's' is an input stream, discard any pending/buffered data.  Otherwise,
  * Write out any buffered data in the stream 's'
  */
 int prot_flush(struct protstream *s) 
 {
+    if (!s->write) {
+	int c, save_dontblock = s->dontblock;
+
+	/* Set stream to nonblocking mode */
+	if (!save_dontblock) nonblock(s->fd, (s->dontblock = 1));
+
+	/* Ingest any pending input */
+	while ((c = prot_fill(s)) != EOF);
+
+	/* Reset stream to previous blocking mode */
+	if (!save_dontblock) nonblock(s->fd, (s->dontblock = 0));
+
+	/* Discard any buffered input */
+	s->cnt = 0;
+
+	return 0;
+    }
+
     return prot_flush_internal(s, 1);
 }
 
--- a/timsieved/parser.c
+++ b/timsieved/parser.c
@@ -401,6 +401,9 @@ int parser(struct protstream *sieved_out
       goto error;
     }
 
+    /* XXX  discard any input pipelined after STARTTLS */
+    prot_flush(sieved_in);
+
     if(referral_host)
 	goto do_referral;
 
