From: =?utf-8?q?Ond=C5=99ej_Sur=C3=BD?= <ondrej@sury.org>
Date: Mon, 23 May 2016 23:15:44 +0200
Subject: Replace the custom icalrecur_add_rule() with reconstructing RRULE
 and parsing it with standard icalrecurrencetype_from_string()

---
 imap/jcal.c |  22 ++++++------
 imap/xcal.c | 112 +++++++++++-------------------------------------------------
 2 files changed, 30 insertions(+), 104 deletions(-)

diff --git a/imap/jcal.c b/imap/jcal.c
index 52b2534..98f8f31 100644
--- a/imap/jcal.c
+++ b/imap/jcal.c
@@ -455,10 +455,6 @@ struct icalrecur_parser {
 };
 
 extern icalrecurrencetype_frequency icalrecur_string_to_freq(const char* str);
-extern void icalrecur_add_byrules(struct icalrecur_parser *parser, short *array,
-				  int size, char* vals);
-extern void icalrecur_add_bydayrules(struct icalrecur_parser *parser,
-				     const char* vals);
 
 static const char *_json_x_value(json_t *jvalue)
 {
@@ -549,19 +545,23 @@ static icalvalue *json_object_to_icalvalue(json_t *jvalue,
 
     case ICAL_RECUR_VALUE:
 	if (json_is_object(jvalue)) {
-	    struct icalrecurrencetype *rt = NULL;
+	    struct icalrecurrencetype rt;
+	    static struct buf buf = BUF_INITIALIZER;
 	    const char *key;
 	    json_t *val;
 
 	    json_object_foreach(jvalue, key, val) {
-		rt = icalrecur_add_rule(&rt, key, val,
-		    (int (*)(void *)) &json_integer_value,
-		    (const char * (*)(void *)) &json_x_value);
-		if (!rt) break;
+		buf_appendcstr(&buf, (const char *)key);
+		buf_appendcstr(&buf, "=");
+		buf_appendcstr(&buf, (const char *)json_x_value(val));
+		buf_appendcstr(&buf, ";");
 	    }
 
-            if (rt && rt->freq != ICAL_NO_RECURRENCE)
-		value = icalvalue_new_recur(*rt);
+	    /* Now reparse it with libical function */
+	    rt = icalrecurrencetype_from_string((const char *)buf_cstring(&buf));
+
+            if (rt.freq != ICAL_NO_RECURRENCE)
+		value = icalvalue_new_recur(rt);
 	}
 	else
 	    syslog(LOG_WARNING, "jCal object object expected");
diff --git a/imap/xcal.c b/imap/xcal.c
index e9f73b0..79f30ca 100644
--- a/imap/xcal.c
+++ b/imap/xcal.c
@@ -681,92 +681,6 @@ extern icalrecurrencetype_frequency icalrecur_string_to_freq(const char* str);
 #ifdef HAVE_RSCALE
 extern icalrecurrencetype_skip icalrecur_string_to_skip(const char* str);
 #endif
-extern void icalrecur_add_byrules(struct icalrecur_parser *parser, short *array,
-				  int size, char* vals);
-extern void icalrecur_add_bydayrules(struct icalrecur_parser *parser,
-				     const char* vals);
-
-struct icalrecurrencetype *icalrecur_add_rule(struct icalrecurrencetype **rt,
-					      const char *rpart, void *data,
-					      int (*get_int)(void *),
-					      const char* (*get_str)(void *))
-{
-    static struct icalrecur_parser parser;
-
-    if (!*rt) {
-	/* Initialize */
-	*rt = &parser.rt;
-	icalrecurrencetype_clear(*rt);
-    }
-
-    if (!strcmp(rpart, "freq")) {
-	(*rt)->freq = icalrecur_string_to_freq(get_str(data));
-    }
-#ifdef HAVE_RSCALE
-    else if (!strcmp(rpart, "rscale")) {
-	(*rt)->rscale = icalmemory_tmp_copy(get_str(data));
-    }
-    else if (!strcmp(rpart, "skip")) {
-	(*rt)->skip = icalrecur_string_to_skip(get_str(data));
-    }
-#endif
-    else if (!strcmp(rpart, "count")) {
-	(*rt)->count = get_int(data);
-    }
-    else if (!strcmp(rpart, "until")) {
-	(*rt)->until = icaltime_from_string(get_str(data));
-    }
-    else if (!strcmp(rpart, "interval")) {
-	(*rt)->interval = get_int(data);
-	if ((*rt)->interval < 1) (*rt)->interval = 1;  /* MUST be >= 1 */
-    }
-    else if (!strcmp(rpart, "wkst")) {
-	(*rt)->week_start = icalrecur_string_to_weekday(get_str(data));
-    }
-    else if (!strcmp(rpart, "byday")) {
-	icalrecur_add_bydayrules(&parser, get_str(data));
-    }
-    else {
-	int i;
-
-	for (i = 0; recurmap[i].str && strcmp(rpart, recurmap[i].str); i++);
-
-	if (recurmap[i].str) {
-	    short *array =
-		(short *)((size_t) *rt + recurmap[i].offset);
-	    int limit = recurmap[i].limit;
-
-	    icalrecur_add_byrules(&parser, array, limit,
-				  icalmemory_tmp_copy(get_str(data)));
-	}
-	else {
-	    syslog(LOG_WARNING, "Unknown recurrence rule-part: %s", rpart);
-	    icalrecurrencetype_clear(*rt);
-	    *rt = NULL;
-	}
-    }
-
-#ifdef HAVE_RSCALE
-    /* When "RSCALE" is not present the default is "YES".
-       When "RSCALE" is present the default is "BACKWARD". */
-    if (!(*rt)->rscale) (*rt)->skip = ICAL_SKIP_YES;
-    else if ((*rt)->skip == ICAL_SKIP_NO) (*rt)->skip = ICAL_SKIP_BACKWARD;
-#endif
-
-    return *rt;
-}
-
-
-int xmlElementContent_to_int(void *content)
-{
-    return atoi((const char *) content);
-}
-
-const char *xmlElementContent_to_str(void *content)
-{
-    return (const char *) content;
-}
-
 
 /*
  * Construct an iCalendar property value from XML content.
@@ -868,22 +782,34 @@ static icalvalue *xml_element_to_icalvalue(xmlNodePtr xtype,
     }
 
     case ICAL_RECUR_VALUE: {
-	struct icalrecurrencetype *rt = NULL;
+	static struct buf buf = BUF_INITIALIZER;
+	struct icalrecurrencetype rt;
 
+	buf_reset(&buf);
+
+	char *dst, *str;
+	size_t dst_len = 0, str_len;
+
+	/* First we count required length of the RRULE string */
 	for (node = xmlFirstElementChild(xtype); node;
 	     node = xmlNextElementSibling(node)) {
 
 	    content = xmlNodeGetContent(node);
-	    rt = icalrecur_add_rule(&rt, (const char *) node->name, content,
-				    &xmlElementContent_to_int,
-				    &xmlElementContent_to_str);
+
+	    buf_appendcstr(&buf, (const char *)node->name);
+	    buf_appendcstr(&buf, (const char *)"=");
+	    buf_appendcstr(&buf, (const char *)content);
+	    buf_appendcstr(&buf, (const char *)";");
+
 	    xmlFree(content);
 	    content = NULL;
-	    if (!rt) break;
 	}
 
-	if (rt && rt->freq != ICAL_NO_RECURRENCE)
-	    value = icalvalue_new_recur(*rt);
+	/* Now reparse it with libical function */
+	rt = icalrecurrencetype_from_string((const char *)buf_cstring(&buf));
+
+	if (rt.freq != ICAL_NO_RECURRENCE)
+	    value = icalvalue_new_recur(rt);
 
 	break;
     }
