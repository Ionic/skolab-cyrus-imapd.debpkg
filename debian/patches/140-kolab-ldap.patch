Description: Kolab upstream's kolab-ldap.patch
Author: Steffen Joeris <steffen.joeris@skolelinux.de>
Forwarded: no
Last-Update: 2022-05-05

---
 Makefile.am     |  2 +-
 imap/global.c   | 58 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 lib/imapoptions |  2 +-
 3 files changed, 59 insertions(+), 3 deletions(-)

diff --git a/Makefile.am b/Makefile.am
index 620ea0ca6..ecb724062 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -574,7 +574,7 @@ com_err/et/compile_et: com_err/et/compile_et.sh com_err/et/config_script \
 # MD5 algorithms, without needing SSL.  Currently we have no way of
 # minimally linking such code.
 LD_BASIC_ADD = lib/libcyrus.la lib/libcyrus_min.la ${LIBS} \
-	${LIB_SASL} $(SSL_LIBS) $(GCOV_LIBS)
+	${LIB_SASL} $(SSL_LIBS) $(GCOV_LIBS) -lldap -llber
 
 # UTILITY is the libraries that utility programs which use Cyrus'
 # mailbox and message handling code need to link with.
diff --git a/imap/global.c b/imap/global.c
index f069eea12..674ca9d39 100644
--- a/imap/global.c
+++ b/imap/global.c
@@ -57,6 +57,9 @@
 #include <openssl/rand.h>
 #endif
 
+#include <ldap.h>
+#include <lber.h>
+
 #if HAVE_UNISTD_H
 # include <unistd.h>
 #endif
@@ -531,6 +534,18 @@ EXPORTED const char *canonify_userid(char *user, const char *loginid,
     char *domain = NULL;
     int len = strlen(user);
     char buf[81];
+    const char *uri;
+    const char *base;
+    const char *binddn;
+    const char *bindpw;
+    struct timeval timeout;
+    char filter[255];
+    LDAP *handle;
+    LDAPMessage *res;
+    LDAPMessage *entry;
+    char ** vals;
+
+    int rc;
 
     /* check for domain */
     if (config_virtdomains &&
@@ -549,6 +564,47 @@ EXPORTED const char *canonify_userid(char *user, const char *loginid,
     }
 
     if (config_virtdomains) {
+        if (config_virtdomains == IMAP_ENUM_VIRTDOMAINS_LDAP) {
+            uri = config_getstring(IMAPOPT_LDAP_URI);
+            base = config_getstring(IMAPOPT_LDAP_BASE);
+            binddn = config_getstring(IMAPOPT_LDAP_BIND_DN);
+            bindpw = config_getstring(IMAPOPT_LDAP_PASSWORD);
+            timeout.tv_sec = config_getint(IMAPOPT_LDAP_TIME_LIMIT);
+            timeout.tv_usec = 0;
+            sprintf(filter, "(uid=%s)", user);
+            rc = ldap_initialize(&handle, uri);
+            if (rc != LDAP_SUCCESS) {
+                syslog(LOG_ERR, "ldap_initialize failed (%s)", uri);
+            } else {
+                rc = ldap_simple_bind_s(handle, binddn, bindpw);
+                if (rc != LDAP_SUCCESS) {
+                    syslog(LOG_ERR, "ldap_simple_bind() failed %d (%s)", rc, ldap_err2string(rc));
+                } else {
+                    rc = ldap_search_st(handle, base, LDAP_SCOPE_SUBTREE, filter, NULL, 0, &timeout, &res);
+                    if (rc != LDAP_SUCCESS) {
+                        syslog(LOG_ERR, "ldap_search_st failed %d (%s)", rc, ldap_err2string(rc));
+                    } else {
+                        if ((entry = ldap_first_entry(handle, res)) != NULL) {
+                            // read mail attribute from entry
+                            if ((vals = ldap_get_values(handle, entry, "mail"))) {
+                                if (strchr(vals[0], '@')) {
+                                    static char buf[81]; /* same size as in auth_canonifyid */
+                                    strncpy( buf, vals[0], sizeof(buf) );
+                                    buf[80] = '\0'; /* make sure it's null-terminated */
+                                    ldap_value_free(vals);
+                                    ldap_msgfree(res);
+                                    ldap_unbind_s(handle); /* also frees handle */
+                                    return auth_canonifyid(buf, 0) ;
+                                }
+                                ldap_value_free(vals);
+                            }
+                        }
+                        ldap_msgfree(res);
+                    }
+                }
+                ldap_unbind_s(handle); /* also frees handle */
+            }
+        }
         if (domain) {
             if (config_defdomain && !strcasecmp(config_defdomain, domain+1)) {
                 *domain = '\0'; /* trim the default domain */
@@ -561,7 +617,7 @@ EXPORTED const char *canonify_userid(char *user, const char *loginid,
                 user = buf;
             }
         }
-        else if (config_virtdomains != IMAP_ENUM_VIRTDOMAINS_USERID) {
+        else if (config_virtdomains != IMAP_ENUM_VIRTDOMAINS_USERID && config_virtdomains != IMAP_ENUM_VIRTDOMAINS_LDAP) {
             socklen_t salen;
             int error;
             struct sockaddr_storage localaddr;
diff --git a/lib/imapoptions b/lib/imapoptions
index c29dc7ee3..f2af58339 100644
--- a/lib/imapoptions
+++ b/lib/imapoptions
@@ -2806,7 +2806,7 @@ product version in the capabilities
    character '.'. Note that with the newnews separator, no dots may
    occur in mailbox names.  The default switched in 3.0 from off to on. */
 
-{ "virtdomains", "off", ENUM("off", "userid", "on"), "3.1.8" }
+{ "virtdomains", "off", ENUM("off", "userid", "ldap", "on"), "3.1.8" }
 /* Configure virtual domain support.
 .PP
 .IP off
