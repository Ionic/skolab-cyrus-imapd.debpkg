Description: cumulative patch for non amd64 arch
Author: Ellie Timoney <https://github.com/elliefm>
Origin: upstream, https://github.com/cyrusimap/cyrus-imapd/compare/cyrus-imapd-3.2...elliefm:v32/3040-crc-alignment
Bug: https://github.com/cyrusimap/cyrus-imapd/issues/3040
Bug-Debian: https://bugs.debian.org/960658
Forwarded: not-needed
Reviewed-By: Xavier Guimard <yadd@debian.org>
Last-Update: 2020-05-25

--- a/configure.ac
+++ b/configure.ac
@@ -181,6 +181,12 @@
   AC_MSG_ERROR(The Cyrus IMAPD requires support for long long int)
 fi
 
+dnl Check the required alignment for various types
+AC_CHECK_ALIGNOF(uint32_t)
+
+dnl check for -R, etc. switch
+CMU_GUESS_RUNPATH_SWITCH
+
 AC_CHECK_HEADERS(unistd.h sys/select.h sys/param.h stdarg.h)
 AC_REPLACE_FUNCS(memmove strcasecmp ftruncate strerror posix_fadvise strsep memmem)
 AC_CHECK_FUNCS(strlcat strlcpy strnchr getgrouplist fmemopen pselect)
--- a/cunit/crc32.testc
+++ b/cunit/crc32.testc
@@ -1,4 +1,5 @@
 /* Unit test for lib/crc32.c */
+#include <config.h>
 #include "cunit/cyrunit.h"
 #include "crc32.h"
 #include "crc32c.h"
@@ -105,6 +106,31 @@
     CU_ASSERT_EQUAL(c, CRC32);
 }
 
+static void test_unaligned(void)
+{
+    struct aligned_data {
+        char pad1[1];
+        char UNALIGNED_TEXT[12];
+        char pad2[3];
+        char ALIGNED_TEXT[12];
+    } __attribute__((packed, aligned (ALIGNOF_UINT32_T)));
+
+    static const struct aligned_data data = {
+        { 0 },
+        "lorem ipsum",
+        { 0 },
+        "lorem ipsum",
+    };
+    static const uint32_t CRC32 = 0x72d7748e;
+    uint32_t c;
+
+    c = crc32_map(data.UNALIGNED_TEXT, sizeof(data.UNALIGNED_TEXT)-1);
+    CU_ASSERT_EQUAL(c, CRC32);
+
+    c = crc32_map(data.ALIGNED_TEXT, sizeof(data.ALIGNED_TEXT)-1);
+    CU_ASSERT_EQUAL(c, CRC32);
+}
+
 static void test_iovec(void)
 {
     static const char TEXT1[] = "lorem";
--- a/cunit/timeout.c
+++ b/cunit/timeout.c
@@ -104,7 +104,7 @@
             exit(1);
         }
 
-        r = read(fd, &c, 1);
+        r = read(fd, &c, sizeof(c));
         if (r < 0) {
             perror("timeout: read");
             exit(1);
@@ -141,7 +141,7 @@
             break;
 
         default:
-            fprintf(stderr, "timeout: Unknown command '%c'\n", c);
+            fprintf(stderr, "timeout: Unknown command '%c' (%#x)\n", c, (unsigned) c);
             exit(1);
         }
     }
@@ -197,7 +197,7 @@
 
 int timeout_begin(int millisec)
 {
-    int c;
+    char c;
     int r;
 
 // fprintf(stderr, "timeout_begin\n");
@@ -205,7 +205,7 @@
         return -1;
 
     c = CMD_BEGIN;
-    r = write(timeout_fd, &c, 1);
+    r = write(timeout_fd, &c, sizeof(c));
     if (r < 0) {
         perror("timeout: write");
         return -1;
@@ -220,7 +220,7 @@
 
 int timeout_end(void)
 {
-    int c;
+    char c;
     int r;
 
 // fprintf(stderr, "timeout_end\n");
@@ -228,7 +228,7 @@
         return -1;
 
     c = CMD_END;
-    r = write(timeout_fd, &c, 1);
+    r = write(timeout_fd, &c, sizeof(c));
     if (r < 0) {
         perror("timeout: write");
         return -1;
--- a/cunit/times.testc
+++ b/cunit/times.testc
@@ -557,22 +557,26 @@
     CU_ASSERT_EQUAL(r, 26);
     CU_ASSERT_EQUAL(t, 1230969900);
 
+#if SIZEOF_TIME_T >= 8
     /* Year 9999 */
     t = UNINIT_TIMET;
     r = time_from_rfc5322("Fri, 31-Dec-9999 23:59:59 +0000", &t, DATETIME_FULL);
     CU_ASSERT_EQUAL(r, 31);
     CU_ASSERT_EQUAL(t, 253402300799);
+#endif
 
     /* Year 1 - This will fail*/
     t = UNINIT_TIMET;
     r = time_from_rfc5322("1 Jan 1 00:00:00 +0000", &t, DATETIME_FULL);
     CU_ASSERT_EQUAL(r, -1);
 
+#if SIZEOF_TIME_T >= 8
     /* 5 digit year */
     t = UNINIT_TIMET;
     r = time_from_rfc5322("Sat, 1 Jan 10000 00:00:00", &t, DATETIME_FULL);
     CU_ASSERT_EQUAL(r, 25);
     CU_ASSERT_EQUAL(t, 253402300800);
+#endif
 
     /* Invalid date */
     t = UNINIT_TIMET;
--- a/imap/annotate.c
+++ b/imap/annotate.c
@@ -982,8 +982,11 @@
     }
 
     if (tmps < end) {
-        mdata->modseq = ntohll(*((unsigned long long *)tmps));
-        tmps += sizeof(unsigned long long);
+        /* make sure ntohll's input is correctly aligned */
+        modseq_t modseq;
+        memcpy(&modseq, tmps, sizeof(modseq));
+        mdata->modseq = ntohll(modseq);
+        tmps += sizeof(modseq_t);
     }
 
     if (tmps < end) {
--- a/imap/httpd.c
+++ b/imap/httpd.c
@@ -2350,7 +2350,7 @@
     simple_hdr(txn, "Access-Control-Expose-Headers", hdr)
 
 static void comma_list_body(struct buf *buf,
-                            const char *vals[], unsigned flags, va_list args)
+                            const char *vals[], unsigned flags, int has_args, va_list args)
 {
     const char *sep = "";
     int i;
@@ -2358,11 +2358,11 @@
     for (i = 0; vals[i]; i++) {
         if (flags & (1 << i)) {
             buf_appendcstr(buf, sep);
-            if (args) buf_vprintf(buf, vals[i], args);
+            if (has_args) buf_vprintf(buf, vals[i], args);
             else buf_appendcstr(buf, vals[i]);
             sep = ", ";
         }
-        else if (args) {
+        else if (has_args) {
             /* discard any unused args */
             vsnprintf(NULL, 0, vals[i], args);
         }
@@ -2377,7 +2377,7 @@
 
     va_start(args, flags);
 
-    comma_list_body(&buf, vals, flags, args);
+    comma_list_body(&buf, vals, flags, 1, args);
 
     va_end(args);
 
@@ -2512,6 +2512,7 @@
     int i;
     time_t now;
     char datestr[30];
+    va_list noargs;
     double cmdtime, nettime;
     const char **hdr, *sep;
     struct auth_challenge_t *auth_chal = &txn->auth_chal;
@@ -3077,17 +3078,17 @@
     }
     if (code == HTTP_SWITCH_PROT || code == HTTP_UPGRADE) {
         buf_printf(logbuf, "%supgrade=", sep);
-        comma_list_body(logbuf, upgrd_tokens, txn->flags.upgrade, NULL);
+        comma_list_body(logbuf, upgrd_tokens, txn->flags.upgrade, 0, noargs);
         sep = "; ";
     }
     if (txn->flags.te) {
         buf_printf(logbuf, "%stx-encoding=", sep);
-        comma_list_body(logbuf, te, txn->flags.te, NULL);
+        comma_list_body(logbuf, te, txn->flags.te, 0, noargs);
         sep = "; ";
     }
     if (txn->resp_body.enc.proc) {
         buf_printf(logbuf, "%scnt-encoding=", sep);
-        comma_list_body(logbuf, ce, txn->resp_body.enc.type, NULL);
+        comma_list_body(logbuf, ce, txn->resp_body.enc.type, 0, noargs);
         sep = "; ";
     }
     if (txn->location) {
--- a/lib/crc32.c
+++ b/lib/crc32.c
@@ -630,7 +630,19 @@
 static uint32_t crc32_slice8(uint32_t prev, const void *data, size_t length)
 {
     uint32_t crc = ~prev;
-    const uint32_t* current = (const uint32_t*) data;
+    unsigned unaligned = (uintptr_t) data % ALIGNOF_UINT32_T;
+    const uint8_t *current_char;
+    const uint32_t *current;
+
+    unaligned = ALIGNOF_UINT32_T - ((uintptr_t) data % ALIGNOF_UINT32_T);
+    if (unaligned == ALIGNOF_UINT32_T) unaligned = 0;
+
+    /* process a byte at a time until we hit an alignment boundary */
+    current_char = (const uint8_t *) data;
+    for (; unaligned && length; unaligned--, length--)
+        crc = (crc >> 8) ^ crc32_lookup[0][(crc & 0xFF) ^ *current_char++];
+
+    current = (const uint32_t *) current_char;
 
     /* process eight bytes at once (Slicing-by-8) */
     while (length >= 8) {
@@ -661,7 +673,7 @@
         length -= 8;
     }
 
-    const uint8_t* current_char = (const uint8_t*) current;
+    current_char = (const uint8_t*) current;
     /* remaining 1 to 7 bytes (standard algorithm) */
     while (length-- != 0)
         crc = (crc >> 8) ^ crc32_lookup[0][(crc & 0xFF) ^ *current_char++];
@@ -673,7 +685,19 @@
 static uint32_t crc32_slice16(uint32_t prev, const void *data, size_t length)
 {
     uint32_t crc = ~prev;
-    const uint32_t* current = (const uint32_t*) data;
+    unsigned unaligned;
+    const uint8_t *current_char;
+    const uint32_t *current;
+
+    unaligned = ALIGNOF_UINT32_T - ((uintptr_t) data % ALIGNOF_UINT32_T);
+    if (unaligned == ALIGNOF_UINT32_T) unaligned = 0;
+
+    /* process a byte at a time until we hit an alignment boundary */
+    current_char = (const uint8_t *) data;
+    for (; unaligned && length; unaligned--, length--)
+        crc = (crc >> 8) ^ crc32_lookup[0][(crc & 0xFF) ^ *current_char++];
+
+    current = (const uint32_t *) current_char;
 
     /* enabling optimization (at least -O2) automatically unrolls the inner for-loop */
     const size_t unroll = 4;
@@ -730,7 +754,7 @@
         length -= bytes_at_once;
     }
 
-    const uint8_t* current_char = (const uint8_t*) current;
+    current_char = (const uint8_t*) current;
     /* remaining 1 to 63 bytes (standard algorithm) */
     while (length-- != 0)
         crc = (crc >> 8) ^ crc32_lookup[0][(crc & 0xFF) ^ *current_char++];
